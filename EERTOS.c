#include <EERTOS.h>

#define TaskQueueMask  (TaskQueueSize - 1)

// Очереди задач, таймеров.
// Тип данных - указатель на функцию
volatile static TPTR	TaskQueue[TaskQueueSize];			// очередь указателей
u08 TaskQueue_Head;
u08 TaskQueue_Tail;
volatile static struct
{									
	TPTR GoToTask; 						// Указатель перехода
	u16 Time;							// Выдержка в мс
} MainTimer[MainTimerQueueSize];	// Очередь таймеров

// RTOS Подготовка. Очистка очередей
inline void InitRTOS(void)
{
	u08	index;

	TaskQueue_Head = 0;
	TaskQueue_Tail = 0;


	for(index=0;index!=MainTimerQueueSize;index++) // Обнуляем все таймеры.
	{
		MainTimer[index].GoToTask = Idle;
		MainTimer[index].Time = 0;
	}
}


//Пустая процедура - простой ядра. 
inline void  Idle(void)
{
	set_sleep_mode(SLEEP_MODE_IDLE);
  	sleep_mode();
}


// Функция установки задачи в очередь. Передаваемый параметр - указатель на функцию
// Отдаваемое значение - код ошибки.
void SetTask(TPTR TS)
{
	u08	nointerrupted = 0;

	if (STATUS_REG & (1<<Interrupt_Flag))  // Если прерывания разрешены, то запрещаем их.
	{
		Disable_Interrupt
		nointerrupted = 1;					// И ставим флаг, что мы не в прерывании. 
	}

	if ((u08)(TaskQueue_Tail - TaskQueue_Head) & (u08)~TaskQueueMask) // буфер полон
    {
    	if (nointerrupted)	Enable_Interrupt 	// Если мы не в прерывании, то разрешаем прерывания
		return;									// Раньше функция возвращала код ошибки - очередь переполнена. Пока убрал.
    }

    TaskQueue[TaskQueue_Tail & TaskQueueMask] = TS;  	//добавляем в очередь задачу
    ++TaskQueue_Tail;                                	//сдвигаем хвост
	
	if (nointerrupted) Enable_Interrupt					// И включаем прерывания если не в обработчике прерывания.
}


//Функция установки задачи по таймеру. Передаваемые параметры - указатель на функцию, 
// Время выдержки в тиках системного таймера. Возвращет код ошибки.
void SetTimerTask(TPTR TS, u16 NewTime)
{
	u08	index;
	u08 index_Empty;
	BOOL buff_Full;
	u08	nointerrupted = 0;

	if (STATUS_REG & (1<<Interrupt_Flag)) 			// Проверка запрета прерывания, аналогично функции выше
	{
		Disable_Interrupt
		nointerrupted = 1;
	}

	index_Empty = 0;
	buff_Full = TRUE;
	for(index=0;index!=MainTimerQueueSize;++index)	//Прочесываем очередь таймеров
	{
		if (MainTimer[index].GoToTask == Idle)      //Если есть место под таймер запомним его
		{
			index_Empty = index;
			buff_Full = FALSE;
		}
		else
			if (MainTimer[index].GoToTask == TS)			// Если уже есть запись с таким адресом
			{
				MainTimer[index].Time = NewTime;			// Перезаписываем ей выдержку
				if (nointerrupted) 	Enable_Interrupt		// Разрешаем прерывания если не были запрещены.
				return;										// Выходим. Раньше был код успешной операции. Пока убрал
			}
	}
	if (~buff_Full)
	{
		MainTimer[index_Empty].GoToTask = TS;			// Заполняем поле перехода задачи
		MainTimer[index_Empty].Time = NewTime;		// И поле выдержки времени
	}
	if (nointerrupted) 	Enable_Interrupt	// Разрешаем прерывания
}


/*=================================================================================
Диспетчер задач ОС. Выбирает из очереди задачи и отправляет на выполнение.
*/

inline void TaskManager(void)
{
	TPTR GoToTask;
	Disable_Interrupt				// Запрещаем прерывания!!!
	if (TaskQueue_Head == TaskQueue_Tail)               //если буфер задач пуст
	{
		Enable_Interrupt			// Разрешаем прерывания
		Idle(); 					// Переходим на обработку пустого цикла
	}
    else
    {                   
        GoToTask = TaskQueue[TaskQueue_Head & TaskQueueMask];   //считываем адрес задачи  
        ++TaskQueue_Head;                                    	//сдвигаем голову 
        Enable_Interrupt							// Разрешаем прерывания
		(GoToTask)();								// Переходим к задаче
    }
}


/*
Служба таймеров ядра. Должна вызываться из прерывания раз в 1мс. Хотя время можно варьировать в зависимости от задачи

To DO: Привести к возможности загружать произвольную очередь таймеров. Тогда можно будет создавать их целую прорву. 
А также использовать эту функцию произвольным образом. 
В этом случае не забыть добавить проверку прерывания. 
*/
inline void TimerService(void)
{
	u08 index;

	for(index=0;index!=MainTimerQueueSize;index++)		// Прочесываем очередь таймеров
	{
		if(MainTimer[index].GoToTask != Idle)
		{
			if(MainTimer[index].Time !=0)						// Если таймер не выщелкал, то щелкаем еще раз. 												// To Do: Вычислить по тактам, что лучше !=1 или !=0. 
				MainTimer[index].Time --;						// Уменьшаем число в ячейке если не конец.

			else
			{
				SetTask(MainTimer[index].GoToTask);				// Дощелкали до нуля? Пихаем в очередь задачу
				MainTimer[index].GoToTask = Idle;				// А в ячейку пишем затычку
			}
		}
	}
}
